{"ast":null,"code":"import { BehaviorSubject, of } from 'rxjs';\nimport { catchError, finalize, tap } from 'rxjs/operators';\nimport { PaginatorState } from '../models/paginator.model';\nimport { SortState } from '../models/sort.model';\nimport { GroupingState } from '../models/grouping.model';\nimport { environment } from '../../../../../environments/environment';\nconst DEFAULT_STATE = {\n  filter: {},\n  paginator: new PaginatorState(),\n  sorting: new SortState(),\n  searchTerm: '',\n  grouping: new GroupingState(),\n  entityId: undefined\n};\nexport class TableService {\n  constructor(http) {\n    // Private fields\n    this._items$ = new BehaviorSubject([]);\n    this._isLoading$ = new BehaviorSubject(false);\n    this._isFirstLoading$ = new BehaviorSubject(true);\n    this._tableState$ = new BehaviorSubject(DEFAULT_STATE);\n    this._errorMessage = new BehaviorSubject('');\n    this._subscriptions = []; // API URL has to be overrided\n\n    this.API_URL = `${environment.baseURL}/endpoint`;\n    this.http = http;\n  } // Getters\n\n\n  get items$() {\n    return this._items$.asObservable();\n  }\n\n  get isLoading$() {\n    return this._isLoading$.asObservable();\n  }\n\n  get isFirstLoading$() {\n    return this._isFirstLoading$.asObservable();\n  }\n\n  get errorMessage$() {\n    return this._errorMessage.asObservable();\n  }\n\n  get subscriptions() {\n    return this._subscriptions;\n  } // State getters\n\n\n  get paginator() {\n    return this._tableState$.value.paginator;\n  }\n\n  get filter() {\n    return this._tableState$.value.filter;\n  }\n\n  get sorting() {\n    return this._tableState$.value.sorting;\n  }\n\n  get searchTerm() {\n    return this._tableState$.value.searchTerm;\n  }\n\n  get grouping() {\n    return this._tableState$.value.grouping;\n  } // CREATE\n  // server should return the object with ID\n\n\n  create(item) {\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    return this.http.post(this.API_URL, item).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('CREATE ITEM', err);\n      return of({\n        id: undefined\n      });\n    }), finalize(() => this._isLoading$.next(false)));\n  } // READ (Returning filtered list of entities)\n\n\n  find(tableState) {\n    const url = this.API_URL + '/find';\n\n    this._errorMessage.next('');\n\n    return this.http.post(url, tableState).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('FIND ITEMS', err);\n      return of({\n        items: [],\n        total: 0\n      });\n    }));\n  }\n\n  getItemById(id) {\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    const url = `${this.API_URL}/${id}`;\n    return this.http.get(url).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('GET ITEM BY IT', id, err);\n      return of({\n        id: undefined\n      });\n    }), finalize(() => this._isLoading$.next(false)));\n  } // UPDATE\n\n\n  update(item) {\n    const url = `${this.API_URL}/${item.id}`;\n\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    return this.http.put(url, item).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('UPDATE ITEM', item, err);\n      return of(item);\n    }), finalize(() => this._isLoading$.next(false)));\n  } // UPDATE Status\n\n\n  updateStatusForItems(ids, status) {\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    const body = {\n      ids,\n      status\n    };\n    const url = this.API_URL + '/updateStatus';\n    return this.http.put(url, body).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('UPDATE STATUS FOR SELECTED ITEMS', ids, status, err);\n      return of([]);\n    }), finalize(() => this._isLoading$.next(false)));\n  } // DELETE\n\n\n  delete(id) {\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    const url = `${this.API_URL}/${id}`;\n    return this.http.delete(url).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('DELETE ITEM', id, err);\n      return of({});\n    }), finalize(() => this._isLoading$.next(false)));\n  } // delete list of items\n\n\n  deleteItems(ids = []) {\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    const url = this.API_URL + '/deleteItems';\n    const body = {\n      ids\n    };\n    return this.http.put(url, body).pipe(catchError(err => {\n      this._errorMessage.next(err);\n\n      console.error('DELETE SELECTED ITEMS', ids, err);\n      return of([]);\n    }), finalize(() => this._isLoading$.next(false)));\n  }\n\n  fetch() {\n    this._isLoading$.next(true);\n\n    this._errorMessage.next('');\n\n    const request = this.find(this._tableState$.value).pipe(tap(res => {\n      this._items$.next(res.items);\n\n      this.patchStateWithoutFetch({\n        paginator: this._tableState$.value.paginator.recalculatePaginator(res.total)\n      });\n    }), catchError(err => {\n      this._errorMessage.next(err);\n\n      return of({\n        items: [],\n        total: 0\n      });\n    }), finalize(() => {\n      this._isLoading$.next(false);\n\n      const itemIds = this._items$.value.map(el => {\n        const item = el;\n        return item.id;\n      });\n\n      this.patchStateWithoutFetch({\n        grouping: this._tableState$.value.grouping.clearRows(itemIds)\n      });\n    })).subscribe();\n\n    this._subscriptions.push(request);\n  }\n\n  setDefaults() {\n    this.patchStateWithoutFetch({\n      filter: {}\n    });\n    this.patchStateWithoutFetch({\n      sorting: new SortState()\n    });\n    this.patchStateWithoutFetch({\n      grouping: new GroupingState()\n    });\n    this.patchStateWithoutFetch({\n      searchTerm: ''\n    });\n    this.patchStateWithoutFetch({\n      paginator: new PaginatorState()\n    });\n\n    this._isFirstLoading$.next(true);\n\n    this._isLoading$.next(true);\n\n    this._tableState$.next(DEFAULT_STATE);\n\n    this._errorMessage.next('');\n  } // Base Methods\n\n\n  patchState(patch) {\n    this.patchStateWithoutFetch(patch);\n    this.fetch();\n  }\n\n  patchStateWithoutFetch(patch) {\n    const newState = Object.assign(this._tableState$.value, patch);\n\n    this._tableState$.next(newState);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}