import * as Sql from "jm-ez-mysql";
import * as _ from "lodash";
import { Tables } from "../../../config/tables";
import { ResponseBuilder } from "../../../helpers/responseBuilder";
import { Utils } from "../../../helpers/utils";
import { Jwt } from "../../../helpers/jwt";
import * as jwt from "jsonwebtoken";
import * as csvParser from "csv-parser";
import * as fs from "fs";
import * as My from "jm-ez-mysql";
import { SendEmail } from "../../../helpers/sendEmail";
import { Constants } from '../../../config/constants';
import { table } from "console";

// import * as excelToJson from "convert-excel-to-json";
const excelToJson = require('convert-excel-to-json');
const bcrypt = require('bcryptjs');
const saltRounds = 10;

export class UserUtils {

  /**
   * Create user query
   */
  public async getportal(url: string) {
    return await My.first(Tables.PORTAL, ["*"], "url = ?", [url]);
  }

  public async createUser(userDetail: Json): Promise<ResponseBuilder> {
    const newUser = await Sql.insert(Tables.USERS, userDetail);
    const User = await Sql.query("UPDATE " + Tables.USERS + " SET email = AES_ENCRYPT('" + userDetail.email + "', '" + process.env.SECRET_KEY + "'), phone = AES_ENCRYPT('" + userDetail.phone + "', '" + process.env.SECRET_KEY + "') WHERE id = ?", [newUser.insertId]);
    // Update query as we don't know what all fields will the userDetail array might have inside 

    return ResponseBuilder.data({ id: newUser.insertId });
  }

  /**
   * get User by email
   */
  public async getUserByEmail(email: string): Promise<ResponseBuilder> {
    const user = await Sql.query("SELECT u.id, u.first_name,u.designation,u.department,u.team,u.practice, u.last_name, u.password, u.email, u.profile_image,AES_DECRYPT(u.phone, '" + process.env.SECRET_KEY + "') as phone, u.isVerified, u.role_id, u.role_permission, u.user_permission, CONCAT('[{', GROUP_CONCAT(DISTINCT REPLACE(REPLACE(roles.rights, '[{', ''), '}]', '')), '}]') AS permissions, AES_DECRYPT(u.otp, '" + process.env.SECRET_KEY + "') as otp, u.otp_sent_time, u.status, u.otp_count FROM " + Tables.USERS + " as u LEFT JOIN roles ON FIND_IN_SET(roles.id, u.role_id) WHERE u.email LIKE ? GROUP BY u.id limit 1", [email]);
   console.log(user);
   
    return ResponseBuilder.data(user);
  }


  public async getUserByName(fName: string,lName:string): Promise<ResponseBuilder> {
    const user = await Sql.query("SELECT u.id, u.first_name,u.last_name,u.email WHERE u.first_name AND u.last_name LIKE ? ", [fName,lName]);
   console.log(user);
   
    return ResponseBuilder.data(user);
  }

  public async getUserAllDetails(email: string): Promise<ResponseBuilder> {
    const user = await Sql.query("SELECT * FROM " + Tables.USERS + " WHERE email LIKE ?", [email]);
    return ResponseBuilder.data(user);
  }

  /**
   * Update device token generated by authorization
   */
  public async updateDeviceToken(deviceToken, userId) {
    try {
      return await Sql.update(Tables.USERS, { deviceToken }, "id = ?", [userId]);
    } catch (err) {
      throw ResponseBuilder.error(err);
    }
  }

  /**
   * Update deviceId generated by authorization
   */
  public async updateDeviceID(deviceId, userId) {
    try {
      return await Sql.update(Tables.USERS, { deviceId }, "id = ?", [userId]);
    } catch (err) {
      throw ResponseBuilder.error(err);
    }
  }

  /**
   * Update role data
   */
  public async updateRoleData(id, data) {
    try {
      const updatedUser = await Sql.update(Tables.USERS, { "role_name": data.name, "role_permission": data.rights }, `role_id = ?`, [id]);

      return updatedUser;
    } catch (err) {
      throw ResponseBuilder.error(err);
    }
  }

  /**
   * Update password
   */
  public async updatePassword(password, userId) {
    const data = await Sql.update(Tables.USERS, { password: password, updated_by: userId }, "id = ?", [userId]);

    return ResponseBuilder.data({ data: data });
  }

  /**
   * verify the user after sign up
   */
  public async verify(req): Promise<ResponseBuilder> {
    // comapre url and email hash
    const userDetail = await Sql.first(Tables.USERS, ["id"], "emailHash = ?", [
      req.query.id,
    ]);
    if (userDetail) {
      const updateRes = await Sql.update(`${Tables.USERS}`, { isVerified: 1 }, "emailHash = ?", [
        req.query.id,
      ]);
      if (updateRes !== null || updateRes !== undefined) {
        return ResponseBuilder.data(userDetail);
      } else {
        return ResponseBuilder.data({});
      }
    } else {
      return ResponseBuilder.data({});
    }
  }

  /**
   * Reset Password
   */
  public async resetPassword(req): Promise<ResponseBuilder> {
    const tokenData = await Jwt.decodeAuthToken(req.token);
    if (tokenData) {
      req.id = await Number(tokenData?.userId);
    }
    const users = await Sql.query(`SELECT * FROM ${Tables.USERS} WHERE status != 2 AND id = ${req.id}`);
    const isMatch = await Utils.compareEncryptedText(
      req.newPassword,
      users[0].password
    );
    if (isMatch) {
      return ResponseBuilder.errorMessage(req.t("OLD_PASSWORD_WRONG_RESET"))
    } else if (req.newPassword && req.token) {
      const hash = await Utils.encryptText(req.newPassword);
      req.newPassword = hash;
      if (tokenData) {
        req.updated_at = new Date();
        const id = req.id;
        const data: any = await Sql.update(`${Tables.USERS}`, { password: hash, updated_at: req.updated_at, updated_by: id }, "id= ?", [
          id,
        ]);
        return ResponseBuilder.data(data);
      } else {
        return ResponseBuilder.errorMessage(req.t("TOKEN_INVALID"))
      }

    }
  }

  /**
   * Get all users
   */
  public async usercount() {

    return await Sql.query("SELECT " +
      "(SELECT COUNT(Id) FROM " + Tables.USERS + ") AS User," +
      "(SELECT COUNT(Id) FROM " + Tables.PORTAL + ") AS Portal," +
      "(SELECT COUNT(Id) FROM " + Tables.MODULES + ") AS Module," +
      "(SELECT COUNT(Id) FROM " + Tables.RIGHTS + ") AS Rights," +
      "(SELECT COUNT(Id) FROM " + Tables.ROLES + ") AS Roles," +
      "(SELECT COUNT(Id) FROM " + Tables.MENUS + ") AS Menu");
  }

  public async getAll(req: any) {
    let response;

    //search
    let filters = '';
    if (req.filters) {
      if (req.filters.search) {
        filters += ` AND (${Tables.USERS}.first_name LIKE '%${req.filters.search}%' OR AES_DECRYPT(${Tables.USERS}.email, '${process.env.SECRET_KEY}') LIKE '%${req.filters.search}%' OR AES_DECRYPT(${Tables.USERS}.phone, '${process.env.SECRET_KEY}') LIKE '%${req.filters.search}%' ) `;
      }
      if (req.filters.hasOwnProperty('status')) {
        filters += ` AND ${Tables.USERS}.status = ${req.filters.status}`;
      }
      if (req.filters.hasOwnProperty('role_id')) {
        filters += ` AND ${Tables.USERS}.role_id IN (${req.filters.role_id})`;
      }
    }

    //pagination
    let offset;
    if (req.limit && req.page) {
      offset = (req.page - 1) * req.limit;
    }

    //sorting
    let orderBy = ` ORDER BY ${Tables.USERS}.id DESC`;
    if (req.sortDir && req.sortField) {
      if (req.sortField == 'email') {
        orderBy = ` ORDER BY ${Tables.USERS}.${req.sortField} ${req.sortDir}`
      } else if (req.sortField == 'phone') {
        orderBy = ` ORDER BY ${Tables.USERS}.${req.sortField} ${req.sortDir}`
      } else if (req.sortField == 'role_name') {
        orderBy = ` ORDER BY ${Tables.ROLES}.${req.sortField} ${req.sortDir}`
      } else {
        orderBy = ` ORDER BY ${Tables.USERS}.${req.sortField} ${req.sortDir}`
      }
    }

    //query
    // let query = `SELECT u.* from ${Tables.USERS} as u WHERE u.status != 2  `;
    let query = "SELECT " +
      Tables.USERS + ".*, GROUP_CONCAT(DISTINCT " + Tables.ROLES + ".name ORDER BY " + Tables.ROLES + ".id) AS role_name,AES_DECRYPT(" + Tables.USERS + ".email, '" + process.env.SECRET_KEY + "') AS email_new, AES_DECRYPT(" + Tables.USERS + ".phone, '" + process.env.SECRET_KEY + "') AS phone_new, AES_DECRYPT(" + Tables.USERS + ".otp, '" + process.env.SECRET_KEY + "') AS otp_new FROM " + Tables.USERS + " LEFT JOIN " + Tables.ROLES + " ON FIND_IN_SET(" + Tables.ROLES + ".id, " + Tables.USERS + ".role_id) > 0 WHERE " + Tables.USERS + ".status != 2 ";

    if (filters != '') {
      query += filters;
    }
    query += ` GROUP BY ${Tables.USERS}.id `;
    query += orderBy;

    let newFilter = '';
    if (req.filters.hasOwnProperty('role')) {
      const MyRoleFilter = req.filters.role;
      MyRoleFilter.forEach((element, index) => {
        if (index == 0) {
          newFilter += `AND res.role_name LIKE '%${element}%' `;
        }
        else {
          newFilter += `OR res.role_name LIKE '%${element}%' `;
        }
      });
    }

    let newQuery = `SELECT * FROM ( ` + query + ` ) AS res WHERE 1 = 1 ${newFilter} `;

    let totalItems = await Sql.query(newQuery);

    if (req.limit && req.page) {
      newQuery += ` LIMIT ` + req.limit + ` OFFSET ` + offset;
      let result = await Sql.query(newQuery);

      response = {
        "totalItems": totalItems.length,
        "items": result
      }
    } else {
      response = {
        "totalItems": totalItems.length,
        "items": totalItems
      }
    }

    return response;
  }

  /**
   * Get single record
   */
  public async getOne(id: any) {
    // return await Sql.query("SELECT *, AES_DECRYPT(email, '" + process.env.SECRET_KEY + "') as email_new, AES_DECRYPT(phone, '" + process.env.SECRET_KEY + "') as phone_new, AES_DECRYPT(otp, '" + process.env.SECRET_KEY + "') as otp_new FROM " + Tables.USERS + " WHERE status != 2 AND id = ? ", [Number(id)]);

    return await Sql.query("SELECT u.*, u.email, CONCAT('[{', GROUP_CONCAT(DISTINCT REPLACE(REPLACE(roles.rights, '[{', ''), '}]', '')), '}]') AS permissions, u.otp FROM " + Tables.USERS + " as u LEFT JOIN roles ON FIND_IN_SET(roles.id, u.role_id) WHERE u.status != 2 AND u.id = ? GROUP BY u.id", [Number(id)]);
  }

  /**
   * Update Record
   */
  public async update(input: any, id: number) {
    const role = await Sql.updateFirst(Tables.USERS, input, `id = ?`, [id]);
    const User = await Sql.query("UPDATE " + Tables.USERS + " SET phone = '" + input.phone + "', email ='" + input.email + "' WHERE id = ?", [id]);

    return role.affectedRows > 0 ? true : false;
  }

  /**
   * Single Delete
   */
  public async delete(id: number, user_id: number) {
    const advantages = await Sql.updateFirst(Tables.USERS, { status: 2, deleted_by: user_id }, `id = ?`, [id]);

    return advantages.affectedRows > 0 ? true : false;
  }

  /**
   * Toggle Status
   */
  public async toggleStatus(ids: string, status: number, user_id: number) {
    const advantages = await Sql.query(`UPDATE ${Tables.USERS} SET status = ${status}, updated_by = ${user_id} WHERE id IN (${ids})`);

    return advantages.affectedRows > 0 ? true : false;
  }

  /**
   * Multiple Delete
   */
  public async deleteMany(ids: string, user_id: number) {
    const advantages = await Sql.query(`UPDATE ${Tables.USERS} SET status = 2, deleted_by = ${user_id} WHERE id IN (${ids})`);

    return advantages.affectedRows > 0 ? true : false;
  }

  /**
   * Generate Authorization token
   */
  public async generateAuthToken(input: any) {
    const userDetail = {
      email: input.email
    };
    const user = await Sql.query("SELECT * FROM " + Tables.USERS + " WHERE AES_DECRYPT(email, '" + process.env.SECRET_KEY + "') LIKE ?", input.email);
    console.log(user);
    if (!user[0].auth_token) {
      userDetail['token'] = jwt.sign(userDetail, process.env.JWT_SECRET);
      const obj = {
        auth_token: userDetail['token']
      }
      const updatedUser = await Sql.update(Tables.USERS, obj, " AES_DECRYPT('" + userDetail.email + "', '" + process.env.SECRET_KEY + "') LIKE ?", [input.email]);
    } else {
      userDetail['token'] = user[0].auth_token;
    }
    return userDetail;
  }

  /**
   * Import users from file
   */
  public async bulkImport(req, res): Promise<void> {
    if (req.files) {
      const file = req.files;
      let role = [];
      let query = await `SELECT * from ${Tables.ROLES} WHERE status != 2 `;
      role = await My.query(query);
      const imageUploade: any = await Utils.upload(req.files);

      const fileName = imageUploade.filename.substring(imageUploade.filename.lastIndexOf(".") + 1, imageUploade.filename.length);
      if (fileName == "csv") {
        this.bulkInsertUsingCsv(req, res, imageUploade.path, role);
      } else {
        const result = excelToJson({ sourceFile: imageUploade.path });
        const finalArr = [];
        const option = [];
        if (result["Sheet1"]) {
          const keyArray: any = Object.values(result["Sheet1"][0]);
          let k = 10;
          for (let i = 1; i < result["Sheet1"].length; i++) {
            k--;
            const obj = {};
            for (let j = 0; j < keyArray.length; j++) {
              if (keyArray[j] == "password") {
                // now we set user password to hashed password
                obj[keyArray[j]] = await Utils.encryptText(result["Sheet1"][i][((i + j + k).toString(36)).toUpperCase()]);
              } else if (keyArray[j] == "role_id") {
                let data = result["Sheet1"][i][((i + j + k).toString(36)).toUpperCase()]
                if (data.includes(",")) {
                  const roles = data.split(",");
                  let selectedRole = [];
                  for (let i = 0; i < roles.length; i++) {
                    let cammelVal = roles[i].charAt(0).toUpperCase() + roles[i].toLowerCase().slice(1)
                    let roleData = role.find(val => (val.name == roles[i] || val.name == cammelVal));
                    selectedRole.push(roleData ? roleData.id : '')
                  }
                  obj[keyArray[j]] = await selectedRole.toString();
                } else {
                  const cammelVal = data.charAt(0).toUpperCase() + data.toLowerCase().slice(1)
                  let roleData = role.find(val => (val.name == data || val.name == cammelVal));
                  obj[keyArray[j]] = roleData ? roleData.id : '';
                }
              } else {
                if (result["Sheet1"][i][((i + j + k).toString(36)).toUpperCase()]) {
                  obj[keyArray[j]] = result["Sheet1"][i][((i + j + k).toString(36)).toUpperCase()];
                } else {
                  obj[keyArray[j]] = null;
                }
              }
            }
            finalArr.push(obj);
          }
          fs.unlinkSync(imageUploade.path);

          return await My.insertMany(Tables.USERIMPORT, finalArr);
        } else {
          res.status(Constants.BAD_REQ).json(ResponseBuilder.badRequest(req.t("FILE_ERROR")));
        }
      }
      //}).catch((err) => {
      //  console.log(err);
      //  this.returnData(req, res, resolve, reject, err, []);
      //});
    }
    //return await Sql.insertMany(Tables.USERS, userDetail);
  }

  /**
   * Bulk Insert in user_imports
   */
  bulkInsertUsingCsv(req, res, path, role) {
    return new Promise(async (resolve, reject) => {
      const results = [];
      fs.createReadStream(path)
        .pipe(csvParser())
        .on("data", (data) => {
          if (data.role_id.includes(",")) {
            const roles = data.role_id.split(",");
            let selectedRole = [];
            for (let i = 0; i < roles.length; i++) {
              let cammelVal = roles[i].charAt(0).toUpperCase() + roles[i].toLowerCase().slice(1)
              let roleData = role.find(val => (val.name == roles[i] || val.name == cammelVal));
              selectedRole.push(roleData.id)
            }
            data.role_id = selectedRole.toString();
          } else {
            const cammelVal = data.role_id.charAt(0).toUpperCase() + data.role_id.toLowerCase().slice(1)
            let roleData = role.find(val => (val.name == data.role_id || val.name == cammelVal));
            data.role_id = roleData.id;
          }
          results.push(data);
        })
        .on("end", async () => {
          return await My.insertMany(Tables.USERIMPORT, results);
        });
    });
  }

  /**
   * Get data from user_imports table
   * @returns 
   */
  public async getDataFromImportTable() {
    let query = "SELECT *, AES_ENCRYPT(email, '" + process.env.SECRET_KEY + "') as email_new, AES_ENCRYPT(phone, '" + process.env.SECRET_KEY + "') as phone_new from " + Tables.USERIMPORT;
    let data = await Sql.query(query);
    let userArr = [];
    for (let i = 0; i < data.length; i++) {
      const user = await Sql.query("SELECT count(u.id) as count FROM " + Tables.USERS + " AS u WHERE AES_DECRYPT(u.email, '" + process.env.SECRET_KEY + "') LIKE AES_DECRYPT('" + data[i].email.toString() + "', '" + process.env.SECRET_KEY + "') AND u.status != 2")
      if (!user[0].count) {
        delete data[i].id;
        data[i]['is_import'] = 1;
        const token = Jwt.getAuthToken({ userId: data[i], device_token: '' });
        const url = 'http://localhost:4200/auth/set-password/' + token;
        const userDetails = data[i];
        const emailData = {
          "reset_password_link": url,
          "username": await Utils.titleCase(data[i].first_name)
        }
        SendEmail.sendRawMail("forgot-password", emailData, [data[i].email], `Reset Password`, "");
        data[i].email = data[i].email_new;
        data[i].phone = data[i].phone_new;
        delete data[i].email_new;
        delete data[i].phone_new;
        await userArr.push(data[i]);
      }
    }
    await My.insertMany(Tables.USERS, userArr);
    await My.delete(Tables.USERIMPORT, "id > 0");

    return await userArr;
  }

  /**
   * Update OTP related data
   */
  public async updateOTP(input, userId) {
    try {
      const otp = await Sql.update(Tables.USERS, input, "id = ?", [userId]);

      return await Sql.query("UPDATE " + Tables.USERS + " SET otp = AES_ENCRYPT('" + input.otp + "', '" + process.env.SECRET_KEY + "')WHERE id = " + userId + "", input);
    } catch (err) {
      throw ResponseBuilder.error(err);
    }
  }

  /**
   * Update existing record with encryption
   */
  public async updateExistingData() {
    const result = await Sql.query(`SELECT id, phone, street_address FROM ${Tables.USERS_TEST_COPY}`);
    let updated = 0;
    if (result) {
      for await (let item of result) {
        try {

          if (item.street_address != null) {
            item.street_address = item.street_address != null ? `AES_ENCRYPT('${item.street_address}', '${process.env.SECRET_KEY}')` : null;
          } else {
            item.street_address = null;
          }
          item.phone = (item.phone.length) ? `AES_ENCRYPT('${item.phone}', '${process.env.SECRET_KEY}')` : null;

          let sql = await Sql.query(`UPDATE ${Tables.USERS_TEST_COPY} SET phone = ${item.phone},street_address = ${item.street_address} WHERE id = ${item.id}`);
          if (sql.affectedRows > 0) {
            updated++;
          }
        } catch (err) {
          console.error(err);
          throw ResponseBuilder.error(err);
        }
      }
    }
    return updated;
  }

  /**
   * Get all user's email details
   */
  public async getAllUsersEmail() {
    try {
      const result = await Sql.query("SELECT id, email FROM " + Tables.USERS_TEST_COPY);

      return result;
    } catch (err) {
      throw ResponseBuilder.error(err);
    }
  }


  /**
   * Get all user's email details
   */
  public async updateBulkUsersData(data, userId) {

    try {
      const role = await Sql.updateFirst(Tables.USERS_TEST_COPY, data, `id = ?`, [userId]);
      return role.affectedRows > 0 ? true : false;

    } catch (err) {
      throw ResponseBuilder.error(err);
    }

  }

  /**
   * insert multiple record
   */
  public async insertBulkUsersData(data) {
    try {
      return await My.insertMany(Tables.USERS_TEST_COPY, data);
    } catch (err) {
      throw ResponseBuilder.error(err);
    }

  }

  public async getmenu(id: number): Promise<ResponseBuilder> {
 
      // return await My.first(Tables.MENUS, ["*"], "portal_id = ?", [id]);
      return await Sql.query("SELECT * FROM " + Tables.MENUS + " WHERE portal_id =? ", [id]);
    }
  

}